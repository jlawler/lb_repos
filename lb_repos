#!/usr/bin/perl 
use strict;
use warnings;
use Cwd;
use Getopt::Long;
use Data::Dumper;
use YAML;
use File::Path;
use Compress::Zlib;
use File::Temp qw/ tempfile unlink0 /;



#DEFINE ALL THE CONSTANT/INITIALIZE DATA STRUCTURES
my $command_name=get_command_name();

my @config_file_search_path=("/etc/lb_repos.yaml","/etc/$command_name.yaml");
my $RSYNC = "/usr/bin/rsync";
my $RSYNC_OPTIONS = "--progress";

my %kmap= (
  optional         => 'suggests',
  recommended      => 'recommends',
  class            => 'priority',
  package_revision => 'revision',
);

my @pkg_dep_fields = qw(Replaces Provides Depends Pre-Depends 
  Recommends Suggests Conflicts Enhances Breaks);

my @src_dep_fields = qw(Build-Depends Build-Depends-Indep 
  Build-Conflicts Build-Conflicts-Indep);

my @pkg_res_fields = qw(Package Depends Filename Essential);

my @fieldpri = (qw(Package Source Version Architecture Essential Origin Bugs
  Maintainer Installed-Size), @pkg_dep_fields, 
  qw(Filename Size MD5sum Section Priority Description));


my @new_dist_paths=qw(
  dists
  dists/DIST
  pool-DIST
);

my @new_section_paths=qw(
  dists/DIST/SECTION
  dists/DIST/SECTION/binary-ARCH
  pool-DIST/SECTION
);

my $usage="
$command_name:  Builds and maintains package repositories.
\tPlease note that you MUST rebuild after you add files!\n
\tTo add files:  $command_name add DISTRO FILES
\tTo rebuild the repositories:  $command_name rebuild
\tTo sync packages from a mirror:  $command_name sync_mirror
\tTo  list files in the repositories:  $command_name list [distro][/section]\n";

my @months = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
my @days = qw( Sun Mon Tue Wed Thu Fri Sat Sun);

# This maps the fields into the proper case
my %field_case;
@field_case{map{lc($_)} @fieldpri} = @fieldpri;

#END CONSTANTS DEFINITION

#ACTUAL CODE STARTS HERE!  WOOHOO!
# int main(...)  (ie, top level command starts here)
die "do not run this as root\n" if $>==0; 
my $config_file='';
foreach(@config_file_search_path){
  $config_file=$_ if -e $_ && !$config_file;
}

GetOptions('config=s'=>\$config_file);
die "Couldn't find a valid config file! (checked".join(' ',@config_file_search_path).")\n" unless $config_file;
die "cannot open config file $config_file\n" unless -e $config_file;

#End top level command

sub create_release_signature;
#I might be dumb, but too many functions reference each other so I had to
#prototype some.  Minimize was to prototype this one.
#
#FIXME TODO:  I should either prototype them all, none of them. 
#

my ($command, $add_to, @files)=grep(!/^--/,@ARGV);
my $config=read_config($config_file);

$command="" unless $command;

#FIXME TODO Add a way to delete files, and/or delete old versions of files
#Also, add a way to rebuild partial repos
if($command=~/^(re)?build/){
  rebuild_repository();
}elsif($command=~/^list/){
  list_repository();
}elsif($command=~/^add/){
  add_package();
}elsif($command=~/^sync_mirror/){
  sync_packages();
}else{
  die $usage;
}

#FIXME TODO:  Make this differentiate between files that have been added
#but the repo hasn't been rebuilt...
#Also, do more stuff to show if there are multiple version.
#Also, display some of the arch information
sub list_files {
  my ($repo,$distro, $section)=@_;
  my ($path,$keyring)=($repo->{path},$repo->{keyring});
  opendir DH, "$path/pool-$distro/$section/" || next;
  while(my $ent=readdir(DH)){
    print "\t$ent\n" if $ent=~m/\.deb$/;
  }
  closedir DH;
  print "\n";
}



sub create_dirs {
  foreach my $repo_name(keys %{$config->{repositories}}){
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}){ 
      my $DN=$distro->{name};
      foreach my $to_create_o(@new_dist_paths){
        my $to_create=$to_create_o;
        $to_create=~s/DIST/$DN/g;
        unless(-e $repo->{path}."/".$to_create){
          mkdir($repo->{path}."/".$to_create);
          system "chgrp ".$config->{group_owner}.' '.$repo->{path}."/".$to_create." 2>/dev/null" if $config->{group_owner} ;
          system "chmod g+s ".$repo->{path}."/".$to_create." 2>/dev/null" if $config->{group_owner};
        }
      }
      foreach my $utc(@new_section_paths){
        foreach my $section(@{$distro->{sections}}){
          foreach my $arch(@{$distro->{arch}}){
            my $to_create=$utc;
            $to_create=~s/DIST/$DN/g;
            $to_create=~s/SECTION/$section/g;
            $to_create=~s/ARCH/$arch/g;
            unless(-e $repo->{path}."/".$to_create){
              mkdir($repo->{path}."/".$to_create);
              system "chgrp ".$config->{group_owner}.' '.$repo->{path}."/".$to_create." 2>/dev/null" if $config->{group_owner};
              system "chmod g+s ".$repo->{path}."/".$to_create." 2>/dev/null" if $config->{group_owner};
            }
          }
        }
      }
    }
  }
}


sub add_files {
  my ($repo,$distro,$section,@files)=@_;
  my $DN=$distro->{name};
  my $SN=$section;
  create_dirs();
  foreach my $file(@files){
    die "ERROR:\n\tCouldn't find file $file.  NO FILES ADDED\n"  unless(-e $file);
  }
  foreach my $file(@files){
    my ($path,$keyring)=($repo->{path},$repo->{keyring});
    system("cp $file $path/pool-$distro->{name}/$section/");
    print "$file added to the $distro->{name} repository\n";
  }
  print "Don't forget to rebuild the repository!\n";
  exit;
}

#Create the cryptographic signature of the repos.  The signature is only of the
#release file, but the release file contains hashes of the packages files.
sub create_release_signature {
  foreach my $repo_name(keys %{$config->{repositories}}){
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}){
      my ($distro_name, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
      chdir($path) || die $!;
      #system "rm dists/$distro_name/Release.gpg dists/$distro_name/Release.gpg 2>/dev/null";
      system "rm dists/$distro_name/Release.gpg";
      system("gpg --quiet --no-permission-warning --home $keyring --sign -ba -o dists/$distro_name/Release.gpg dists/$distro_name/Release");
      foreach my $ext('','.gpg'){
        system("chgrp ".$config->{group_owner}." dists/$distro_name/Release".$ext." 2>/dev/null") if $config->{group_owner} && ($>==0 || $>==uid("dists/$distro_name/Release"));
        system("chmod 775 dists/$distro_name/Release".$ext) if ($>==0 || $>==uid("dists/$distro_name/Release"));
      }
    }
  }
}

sub uid {
  my $file=shift;
  my @temp=stat($file);
  return $temp[4];
}
sub gid {
  my $file=shift;
  my @temp=stat($file);
  return $temp[5];
}

#read the cached version of the sha1/md5 checksums.
sub read_cache {
  my ($distro,$repo_cache) = @_;
  $distro->{cache}={};
  my $repo_fh;
  return unless -e $repo_cache;
  open $repo_fh,$repo_cache || return;
  while(my $cache_line=<$repo_fh>){
    my ($file,$md5,$sha1,$sha256)=split(',',$cache_line);
    $distro->{cache}->{$file}={}; 
    $distro->{cache}->{$file}->{MD5sum}=$md5; 
    $distro->{cache}->{$file}->{SHA1sum}=$sha1; 
    $distro->{cache}->{$file}->{SHA256sum}=$sha256; 
  }  
  close $repo_fh;
  print STDERR Dumper $distro->{cache};
}

#write the cached version of the sha1/md5 checksums.
sub write_cache {
  my ($distro, $repo_cache )= @_;
  my $cache=$distro->{cache};
  my $repo_fh;
  open $repo_fh,">$repo_cache" || warn "Cannot update cache for ".$distro->{name}."\n";
  foreach my $arch (keys %{$distro->{cache}}){
    foreach my $package_name (keys %{$distro->{cache}->{$arch}}){
      my $package=$distro->{cache}->{$arch}->{$package_name};
      print $repo_fh join(',',($package->{Filename},$package->{MD5sum},$package->{SHA1sum},$package->{SHA256sum}))."\n";
    }
  }
  close $repo_fh;
}


#Creates the "master" packages file
#FIXME TODO: cache package MD5s if possible, and theen use the MD5s. 
sub create_packages_file {
  my $repo=shift;
  foreach my $distro (@{$repo->{distro}}){
    my $distro_cache=read_cache($distro,$repo->{path}."/.cache_".$distro->{name});
    my %files;
    foreach(@{$distro->{arch}}){
      $files{$_}={};
    }
    my($path, $distroname)=($repo->{path}, $distro->{name});
    foreach my $section (@{$distro->{sections}}){
      opendir DH, "$path/pool-$distroname/$section/" || die "COULDN'T OPEN PATH";
      while (my $ent=readdir(DH)){
        my $full_ent="$path/pool-$distroname/$section/$ent";
        next if -d $full_ent;
        my %tv;
        my $data=`dpkg -I $full_ent control`;
      	if ($data eq ""){
    	    warn sprintf("Couldn't call dpkg-deb on %s: %s, skipping package", $ent, $!)."\n";
    	    next;
    	  }
      	if ($?) {
    	    warn sprintf(_g("\`dpkg-deb -I %s control' exited with %d, skipping package"), $ent, $?)."\n";
    	    next;
      	}
    	  while ($data =~ s/^\n*(\S+):[ \t]*(.*(\n[ \t].*)*)\n//) {
    	    my ($key,$value)= (lc $1,$2);
    	    if (defined($kmap{$key})) { $key= $kmap{$key}; }
    	    if (defined($field_case{$key})) { $key= $field_case{$key}; }
    	    $value =~ s/\s+$//;
    	    $tv{$key}= $value;
    	  }
        $tv{'Filename'}="/pool-$distroname/$section/$ent";
        `md5sum $full_ent`=~/([\da-f]{32})/o;
        $tv{'MD5sum'}=$1;
        `sha1sum $full_ent`=~/([\da-f]{40})/o;
        $tv{'SHA1sum'}=$1;
        `sha256sum $full_ent`=~/([\da-f]{64})/o;
        $tv{'SHA256sum'}=$1;


      	my @stat= stat($full_ent) or die sprintf("Couldn't stat %s: %s", $full_ent, $!)."\n";
      	open(C,"md5sum <$full_ent |") || die "$full_ent $!";
      	chop($_=<C>); close(C); $? and die sprintf("\`md5sum < %s' exited with %d", $full_ent, $?)."\n";
      	$tv{'Size'}= $stat[7];
  	
      	if (defined $tv{Revision} and length($tv{Revision})) {
    	    $tv{Version}.= '-'.$tv{Revision};
    	    delete $tv{Revision};
      	}
        my $name=$tv{Package}.$tv{Version};
        $files{$tv{Architecture}}->{$name}=\%tv;
      }
      foreach my $arch (@{$distro->{arch}}){
        my $distro_name=$distro->{name};
        my $packages_name="$path/dists/$distro_name/$section/binary-$arch/Packages";
        unlink($packages_name);
        open(PACKAGES, ">$packages_name") || die "couldnt open $packages_name $!";
        foreach my $p(sort keys %{ $files{$arch}}){
          my $package=$files{$arch}->{$p};
          my ($distro_name, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
          my $record= "";
          for my $key (@fieldpri) {
            next unless defined $$package{$key};
            $record .= "$key: $$package{$key}\n";
          }
          $record .= "\n";
          print PACKAGES $record; 
        }
        my $tarch='all';
        foreach my $p(sort keys %{ $files{$tarch}}){
          my $package=$files{$tarch}->{$p};
          my ($distro_name, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
          my $record= "";
          for my $key (@fieldpri) {
            next unless defined $$package{$key};
            $record .= "$key: $$package{$key}\n";
          }
          $record .= "\n";
          print PACKAGES $record; 
        }
        close PACKAGES;
      }
    }
    $distro->{cache}=\%files;
    write_cache($distro,$repo->{path}."/.cache_".$distro->{name});
  }
}

#creates the release_files.  It's a sort of index of indexes, lists the
#architectures, what OS I have, etc, etc. 
sub create_release_files {
  my $repo=shift;
  my $url=shift;
  foreach my $distro (@{$repo->{distro}}){
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =gmtime();

  my $path=$repo->{path};
  my $prefix="$path/dists/$distro->{name}/" ;
  my %files=(Release => $prefix."Release");
  my %md5;
  my %sha1;
  my %sizes;
  foreach my $section (@{$distro->{sections}}){
    foreach my $arch (@{$distro->{arch}}){
      foreach my $ext ('','.gz','.bz2'){
        my $filename="$section/binary-$arch/Packages$ext";
        next unless -e $prefix.$filename;
        $files{$filename}=$prefix.$filename;
      }
    }
  }
  my $md5s="";
  my $sha1s="";
  foreach my $filename(sort keys %files){
    my $file=$files{$filename};
    my $rfile=$file;
    #we use /dev/null because the release file has to exist in the release file, with MD5/SHA1 computed as if it has size 0.  WTF?
    $file="/dev/null" if $filename eq "Release";
    `md5sum $file`=~/([\da-f]{32})/o;
    my $md5=$1;
    `sha1sum $file`=~/([\da-f]{40})/o;
    my $sha1=$1;
    my $size=-s $file;
    my $fsize=' ' x (16-length($size)) . $size;
    $md5s.=" $md5 $fsize $filename\n";
    $sha1s.=" $sha1 $fsize $filename\n";
  }
  foreach my $filename(sort keys %files){
    my $file=$files{$filename};
  }
  my $output=
"Architectures: ".join(' ',@{$distro->{arch}})."
Codename: $distro->{name}
Components: ".join(' ',@{$distro->{sections}})."
Date: "."$days[$wday], ".sprintf("%02d", $mday )." $months[$mon] ".($year+1900)." $hour:$min:$sec UTC"." 
Description: Packaged by jwl.
Label: (=) ( ".$url." )
Origin: http://$url/
Suite: $distro->{name}
Version: $distro->{version}";
$output.="
MD5Sum:
$md5s" if grep /md5/i,@{$distro->{hashes}};
$output.=
"SHA1:
$sha1s" if grep /sha1/i,@{$distro->{hashes}};
  my $filename="$path/dists/$distro->{name}/Release";
  open RELEASE, ">$filename" || die "can't open file $filename";
  print RELEASE $output;
  close RELEASE;
  }
}


sub create_compressed_packages {
  my $confpath=$config->{ftparchive};
  foreach my $repo_name(keys %{$config->{repositories}}){
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}){
      my ($distro_name, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
      foreach my $arch(@{$distro->{arch} }){
        foreach my $section(@{$distro->{sections} }){
          my ($distro, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
          chdir($path) || die $!;
          system("gzip -c dists/$distro_name/$section/binary-$arch/Packages > dists/$distro/$section/binary-$arch/Packages.gz");
          system("bzip2 -c dists/$distro_name/$section/binary-$arch/Packages > dists/$distro/$section/binary-$arch/Packages.bz2");
          system("chgrp -R ".$config->{group_owner}." $path/dists/$distro_name/$section/binary-$arch"." 2>/dev/null") if $config->{group_owner}  && ($>==0 || $>==uid("$path/dists/$distro_name/$section/binary-$arch"));
          system("chmod -R 775 $path/dists/$distro_name/$section/binary-$arch")  if($>==0 || $>==uid("$path/dists/$distro_name/$section/binary-$arch"));
        }
      }
    }
  }
}






sub read_config {
  my $filename=shift;
  local $/='';
  open CONFIG, "<$filename" || die $!;
  my $config=<CONFIG>;
  close CONFIG;
  return YAML::Load($config);
}



sub get_command_name {
  my @a=(split(/\//,$0));
  return pop @a;
}


#Regenerate the package lists, regenerate
sub rebuild_repository {
  create_dirs();
  foreach my $repo_name(keys %{$config->{repositories}}){
    print "Rebuilding $repo_name\n";
    create_packages_file($config->{repositories}->{$repo_name});
    create_compressed_packages();
    create_release_files($config->{repositories}->{$repo_name},$repo_name);
  }
  create_release_signature;
}

#list all files in the repos.  Right now, this is all files in the repos, not
#necessarily files exported via the packages list.
sub list_repository {
  my $section="";
  if($add_to){
    if($add_to=~m!^(\w*)/(\w*)!){
      $add_to=$1;
      $section=$2;
    }
    #foreach_dsa
    foreach my $repo_name(keys %{$config->{repositories}}){
      my $repo=$config->{repositories}->{$repo_name};
      foreach my $distro (@{$repo->{distro}}){
        list_files($repo,$distro,$section) if(($distro->{name} eq $add_to) ||($distro->{simlink} && $distro->{simlink} eq $add_to));
      }
    }
  }else{
    #foreach_dsa
    foreach my $repo_name(keys %{$config->{repositories}}){
      my $repo=$config->{repositories}->{$repo_name};
      foreach my $distro (@{$repo->{distro}}){
        foreach my $section(@{$distro->{sections}}){
          list_files($repo,$distro,$section);
        }
      }
    }
  }
}

#Top-level function that copies a package into the correct place in the repos
sub add_package {
  unless(@ARGV>2){
    die "invalid number of arguments to add!\n";
  } 
  my $section="main";
  if($add_to=~m!^(\w*)/(\w*)!){
    $add_to=$1;
    $section=$2;
  }
  #die "Unable to find file $file" unless -e $file;
  foreach my $repo_name(keys %{$config->{repositories}}){
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}){ 
      add_files($repo,$distro,$section,@files) if(($distro->{name} eq $add_to) ||($distro->{simlink} && $distro->{simlink} eq $add_to)) ;
    }
  }
  die "unable to find distro $add_to\n"; 
}

#Below this is for cloning repos

sub sync_packages {
	sync_mirror_lists();
  my %package_hash;
  
  foreach my $repo_name (keys %{$config->{repositories}}) {
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}) {
      foreach my $arch (@{$distro->{arch}}) {

				#build a list of packages available to this distro
        foreach my $section (@{$distro->{sections}}) {
					#clear the list
					%package_hash = ();
          #build url and directory names
          my $package_file = "$distro->{mirror_cache}/$distro->{name}/$section/binary-$arch/Packages.gz";
          print "Reading $package_file ...\n";
          load_package_list($package_file, \%package_hash);
					
					my @files = ();
					my @packages = @{$distro->{base_packages}};
					if ($distro->{include_essential} eq "true") {
						push (@packages, get_essentials(\%package_hash));
					}

					foreach my $package (@packages) {
						push (@files, get_list_of_files($package, $distro->{resolve_deps}, \%package_hash));
					}
					
					#uniq names
					@files = keys %{{ map { $_ => 1} @files }};

					my $remote_url = "$distro->{mirror_url}/";
					my $local_dir = "$repo->{path}/pool-$distro->{name}/$section/";

					#get the files
					get($remote_url, $local_dir, \@files);
				}
      }
    }
  }
  
	print "Don't forget to rebuild the repository!\n";
  exit;
}

# gets a list of files from the specified url and puts them in the local dir
sub get {
	my $remote_url = shift;
	my $local_dir = shift;
	my $files = shift;

	#create a temp file to store the list of files that need to be synced
	my ($fh, $filename) = tempfile() or die("Can't create temp file");
	print $fh join("\n",@$files);

	my $cmd;
	if ($remote_url =~ /^rsync/i) {
		$cmd = "$RSYNC $RSYNC_OPTIONS --no-R --files-from=$filename $remote_url $local_dir";
	}
	else {
	  $cmd = "wget -N -B $remote_url -i $filename -P $local_dir";
	}

	system("$cmd");

	unlink0($fh, $filename) or print "Error unlinking file $filename safely";	
	$fh->close();

}

# get a list of esential packages
sub get_essentials {
	my $package_hash = shift;
	my @packages;
	while ((my $key, my $value) = each (%{$package_hash})) {
		if ($value->{Essential} && $value->{Essential} =~ /yes/i) {
			push (@packages, $key);
		}
	}
	return @packages;
}

# Gets a list of files to be downloaded for the given package
# Args:
#		$package - the package to download
#		$resolve_deps - "true" if dependencies are to be resolved
#		$package_hash - a reference to the hash that holds packages and 
#		                associated files.
sub get_list_of_files {
  my $package = shift; 
	my $resolve_deps = shift;
  my $package_hash = shift;
  my $version;

  my %files = (); 
  my @required = ($package);

  while ($package = shift @required) {
    #we'll parse the version, but for now, we'll forget about it
    #since we'll assume the parent repo maintains the appropriate
    #version
    ($package, $version) = split(" ", $package, 2);
    chomp $package;

		#expand stars
		if ($package =~ /\*.*$/) {
			$package =~ s/\*.*$//;
			foreach my $key (keys %$package_hash) {
				if ($key =~ /^$package.*$/) {
					unshift(@required, $key);		
				}
			}
			next;
		}

    if ($files{$package}) {
      next;
    }

    if ($package_hash->{$package}){
      $files{$package} = $package_hash->{$package}->{"Filename"};
			if ($resolve_deps eq "true") {
				if ($package_hash->{$package}->{"Depends"}) {
					unshift(@required, split(',', $package_hash->{$package}->{"Depends"}));
				}
			}
    } 
    else {
      print "Can't resolve $package\n";
    }

  }

  return values %files;
}


sub sync_mirror_lists {
  foreach my $repo_name (keys %{$config->{repositories}}) {
    my $repo=$config->{repositories}->{$repo_name};
    #foreach_dsa
    foreach my $distro (@{$repo->{distro}}) {
      foreach my $section (@{$distro->{sections}}) {
        foreach my $arch (@{$distro->{arch}}) {
          #build url and directory names
          my $remote_url = "$distro->{mirror_url}/dists/$distro->{name}/$section/binary-$arch/";
          my $local_dir = "$distro->{mirror_cache}/$distro->{name}/$section/binary-$arch";
          unless ( -e "$local_dir"  ) {
            mkpath( "$local_dir" );
          }	 
          #sync the Package list
					@files = ("Packages.gz");
          get ($remote_url, $local_dir, \@files);
        }
      }
    }
  }
}

#reads a gzipped package list and parses teh important information
#required for resolving dependencies.
sub load_package_list {
  my $list_name = shift;
  my $package_hash = shift;
  my $gz = gzopen($list_name, "rb") or die("Couldn't read $list_name");

  my $package;

  while ($gz->gzreadline($_) > 0) {
    if (/^Package: (.+)$/) {  ##Package:
      $package = $1;
			
			#this is the beginning of a package section ...
			#for now, with out better reasoning, we will prefer
			#a package "named" for the dependency, rather than
			#"providing" the dependency.  
			if ($package_hash->{$package}) {
				delete $package_hash->{$package};
			}
      $package_hash->{$package}->{"Package"} = $1;
    } 
    elsif (/^Provides: (.+)$/) {
      foreach my $provision (split(", ", $1)) {
        chomp $provision;
        $package_hash->{$provision} = $package_hash->{$package};
      }
    }
    elsif (/^\s*$/) {         ##blank line
      $package = "";
    }
    elsif (/^(\w+): (.+)$/){
      if (grep (/$1/, @pkg_res_fields)) {
        $package_hash->{$package}->{$1} = $2;
      }
    }
  }
  $gz->gzclose();
}
