#!/usr/bin/perl 
use strict;
use warnings;
use Cwd;
use Getopt::Long;
use Data::Dumper;
use YAML;
use File::Path;
use Compress::Zlib;
use File::Temp qw/ tempfile unlink0 /;



#DEFINE ALL THE CONSTANT/INITIALIZE DATA STRUCTURES

my @config_file_search_path=qw!/etc/lb_repos.yaml!;
my $RSYNC = "/usr/bin/rsync";
my $RSYNC_OPTIONS = "--progress";

my %kmap= (
  optional         => 'suggests',
  recommended      => 'recommends',
  class            => 'priority',
  package_revision => 'revision',
);
my @pkg_dep_fields = qw(Replaces Provides Depends Pre-Depends 
  Recommends Suggests Conflicts Enhances Breaks);

my @src_dep_fields = qw(Build-Depends Build-Depends-Indep 
  Build-Conflicts Build-Conflicts-Indep);

my @pkg_res_fields = qw(Package Depends Filename Essential);

my @fieldpri = (qw(Package Source Version Architecture Essential Origin Bugs
  Maintainer Installed-Size), @pkg_dep_fields, 
  qw(Filename Size MD5sum Section Priority Description));


my @new_dist_paths=qw(
  dists
  dists/DIST
  pool-DIST
);
my @new_section_paths=qw(
  dists/DIST/SECTION
  dists/DIST/SECTION/binary-ARCH
  pool-DIST/SECTION
);

my $usage="
$command_name:  Builds and maintains package repositories.
\tPlease note that you MUST rebuild after you add files!\n
\tTo add files:  $command_name add DISTRO FILES
\tTo rebuild the repositories:  $command_name rebuild
\tTo sync packages from a mirror:  $command_name sync_mirror
\tTo  list files in the repositories:  $command_name list [distro][/section]\n";

my @months = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
my @days = qw( Sun Mon Tue Wed Thu Fri Sat Sun);

# This maps the fields into the proper case
my %field_case;
@field_case{map{lc($_)} @fieldpri} = @fieldpri;

#END CONSTANTS DEFINITION

# int main(... is here
my $config_file='';
foreach(@config_file_search_path){
  $config_file=$_ if -e $_ && !$config_file;
}

GetOptions('config=s'=>\$config_file);
die "Couldn't find a valid config file!" unless $config_file;
die "cannot open config file $config_file\n" unless -e $config_file;

my $command_name=get_command_name();
#End top level command

sub create_release_signature;
#I might be dumb, but too many functions reference each other so I had to
#prototype some.  Minimize was to prototype this one.
#
#FIXME TODO:  I should either prototype them all, none of them. 
#

my ($command, $add_to, @files)=grep(!/^--/,@ARGV);
my $config=read_config($config_file);

$command="" unless $command;


if($command=~/^(re)?build/){
  rebuild_repository();
}elsif($command=~/^list/){
  list_repository();
}elsif($command=~/^add/){
  add_package();
}elsif($command=~/^sync_mirror/){
  sync_packages();
}else{
  die $usage;
}

sub list_files {
  my ($repo,$distro, $section)=@_;
  my ($path,$keyring)=($repo->{path},$repo->{keyring});
  opendir DH, "$path/pool-$distro/$section/" || next;
  while(my $ent=readdir(DH)){
    print "\t$ent\n" if $ent=~m/\.deb$/;
  }
  closedir DH;
  print "\n";
}


sub create_dirs {
  foreach my $repo_name(keys %{$config->{repositories}}){
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}){ 
    my $DN=$distro->{name};
    foreach my $to_create_o(@new_dist_paths){
      my $to_create=$to_create_o;
      $to_create=~s/DIST/$DN/g;
      unless(-e $repo->{path}."/".$to_create){
        mkdir($repo->{path}."/".$to_create);
        system "chgrp ".$config->{group_owner}.' '.$repo->{path}."/".$to_create." 2>/dev/null" if $config->{group_owner} ;
      }
    }
    foreach my $utc(@new_section_paths){
      foreach my $section(@{$distro->{sections}}){
        foreach my $arch(@{$distro->{arch}}){
          my $to_create=$utc;
          $to_create=~s/DIST/$DN/g;
          $to_create=~s/SECTION/$section/g;
          $to_create=~s/ARCH/$arch/g;
          unless(-e $repo->{path}."/".$to_create){
            mkdir($repo->{path}."/".$to_create);
            system "chgrp ".$config->{group_owner}.' '.$repo->{path}."/".$to_create." 2>/dev/null" if $config->{group_owner};
          }
        }
      }
    }
  }
  }
}

sub add_files {
  my ($repo,$distro,$section,@files)=@_;
  my $DN=$distro->{name};
  my $SN=$section;
  create_dirs();
  foreach my $file(@files){
    die "ERROR:\n\tCouldn't find file $file.  NO FILES ADDED\n"  unless(-e $file);
  }
  foreach my $file(@files){
    my ($path,$keyring)=($repo->{path},$repo->{keyring});
    system("cp $file $path/pool-$distro->{name}/$section/");
    print "$file added to the $distro->{name} repository\n";
  }
  print "Don't forget to rebuild the repository!\n";
  exit;
}

#Create the cryptographic signature of the repos.  The signature is only of the
#release file, but the release file contains hashes of the packages files.
sub create_release_signature {
  foreach my $repo_name(keys %{$config->{repositories}}){
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}){
    my ($distro_name, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
    chdir($path) || die $!;
    #system "rm dists/$distro_name/Release.gpg dists/$distro_name/Release.gpg 2>/dev/null";
    system "rm dists/$distro_name/Release.gpg";
    system("gpg --quiet --no-permission-warning --home $keyring --sign -ba -o dists/$distro_name/Release.gpg dists/$distro_name/Release");
    foreach my $ext('','.gpg'){
      system("chgrp ".$config->{group_owner}." dists/$distro_name/Release".$ext." 2>/dev/null") if $config->{group_owner} && ($>==0 || $>==uid("dists/$distro_name/Release"));
      system("chmod 775 dists/$distro_name/Release".$ext) if ($>==0 || $>==uid("dists/$distro_name/Release"));
    }
    }
  }
}

sub uid {
  my $file=shift;
  my @temp=stat($file);
  return $temp[4];
}
sub gid {
  my $file=shift;
  my @temp=stat($file);
  return $temp[5];
}

#Creates the "master" packages file
sub create_packages_file {
  my $repo=shift;
  foreach my $distro (@{$repo->{distro}}){
  my %files;
  foreach(@{$distro->{arch}}){
    $files{$_}={};
  }
  my($path, $distroname)=($repo->{path}, $distro->{name});
  foreach my $section (@{$distro->{sections}}){
    opendir DH, "$path/pool-$distroname/$section/" || die "COULDN'T OPEN PATH";
    while (my $ent=readdir(DH)){
      my $full_ent="$path/pool-$distroname/$section/$ent";
      next if -d $full_ent;
      my %tv;
      my $data=`dpkg -I $full_ent control`;
    	if ($data eq ""){
  	    warn sprintf("Couldn't call dpkg-deb on %s: %s, skipping package", $ent, $!)."\n";
  	    next;
  	  }
    	if ($?) {
  	    warn sprintf(_g("\`dpkg-deb -I %s control' exited with %d, skipping package"), $ent, $?)."\n";
  	    next;
    	}
  	  while ($data =~ s/^\n*(\S+):[ \t]*(.*(\n[ \t].*)*)\n//) {
  	    my ($key,$value)= (lc $1,$2);
  	    if (defined($kmap{$key})) { $key= $kmap{$key}; }
  	    if (defined($field_case{$key})) { $key= $field_case{$key}; }
  	    $value =~ s/\s+$//;
  	    $tv{$key}= $value;
  	  }
      $tv{'Filename'}="/pool-$distroname/$section/$ent";
      `md5sum $full_ent`=~/([\da-f]{32})/o;
      $tv{'MD5sum'}=$1;
    	my @stat= stat($full_ent) or die sprintf("Couldn't stat %s: %s", $full_ent, $!)."\n";
    	open(C,"md5sum <$full_ent |") || die "$full_ent $!";
    	chop($_=<C>); close(C); $? and die sprintf("\`md5sum < %s' exited with %d", $full_ent, $?)."\n";
    	$tv{'Size'}= $stat[7];
  	
    	if (defined $tv{Revision} and length($tv{Revision})) {
  	    $tv{Version}.= '-'.$tv{Revision};
  	    delete $tv{Revision};
    	}
      my $name=$tv{Package}.$tv{Version};
      $files{$tv{Architecture}}->{$name}=\%tv;
    }
  foreach my $arch (@{$distro->{arch}}){
    my $distro_name=$distro->{name};
    my $packages_name="$path/dists/$distro_name/$section/binary-$arch/Packages";
    unlink($packages_name);
    open(PACKAGES, ">$packages_name") || die "couldnt open $packages_name $!";
    foreach my $p(sort keys %{ $files{$arch}}){
      my $package=$files{$arch}->{$p};
      my ($distro_name, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
      my $record= "";
      for my $key (@fieldpri) {
        next unless defined $$package{$key};
        $record .= "$key: $$package{$key}\n";
      }
      $record .= "\n";
      print PACKAGES $record; 
    }
    my $tarch='all';
    foreach my $p(sort keys %{ $files{$tarch}}){
      my $package=$files{$tarch}->{$p};
      my ($distro_name, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
      my $record= "";
      for my $key (@fieldpri) {
        next unless defined $$package{$key};
        $record .= "$key: $$package{$key}\n";
      }
      $record .= "\n";
      print PACKAGES $record; 
    }
    close PACKAGES;
  }
  }
  }
}

#creates the release_files.  It's a sort of index of indexes, lists the
#architectures, what OS I have, etc, etc. 
sub create_release_files {
  my $repo=shift;
  my $url=shift;
  foreach my $distro (@{$repo->{distro}}){
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =gmtime();

  my $path=$repo->{path};
  my $prefix="$path/dists/$distro->{name}/" ;
  my %files=(Release => $prefix."Release");
  my %md5;
  my %sha1;
  my %sizes;
  foreach my $section (@{$distro->{sections}}){
    foreach my $arch (@{$distro->{arch}}){
      foreach my $ext ('','.gz','.bz2'){
        my $filename="$section/binary-$arch/Packages$ext";
        next unless -e $prefix.$filename;
        $files{$filename}=$prefix.$filename;
      }
    }
  }
  my $md5s="";
  my $sha1s="";
  foreach my $filename(sort keys %files){
    my $file=$files{$filename};
    my $rfile=$file;
    #we use /dev/null because the release file has to exist in the release file, with MD5/SHA1 computed as if it has size 0.  WTF?
    $file="/dev/null" if $filename eq "Release";
    `md5sum $file`=~/([\da-f]{32})/o;
    my $md5=$1;
    `sha1sum $file`=~/([\da-f]{40})/o;
    my $sha1=$1;
    my $size=-s $file;
    my $fsize=' ' x (16-length($size)) . $size;
    $md5s.=" $md5 $fsize $filename\n";
    $sha1s.=" $sha1 $fsize $filename\n";
  }
  foreach my $filename(sort keys %files){
    my $file=$files{$filename};
  }
  my $output=
"Architectures: ".join(' ',@{$distro->{arch}})."
Codename: $distro->{name}
Components: ".join(' ',@{$distro->{sections}})."
Date: "."$days[$wday], ".sprintf("%02d", $mday )." $months[$mon] ".($year+1900)." $hour:$min:$sec UTC"." 
Description: Packaged by jwl.
Label: (=) ( ".$url." )
Origin: http://$url/
Suite: $distro->{name}
Version: $distro->{version}";
$output.="
MD5Sum:
$md5s" if grep /md5/i,@{$distro->{hashes}};
$output.=
"SHA1:
$sha1s" if grep /sha1/i,@{$distro->{hashes}};
  my $filename="$path/dists/$distro->{name}/Release";
  open RELEASE, ">$filename" || die "can't open file $filename";
  print RELEASE $output;
  close RELEASE;
  }
}


sub create_compressed_packages {
  my $confpath=$config->{ftparchive};
  foreach my $repo_name(keys %{$config->{repositories}}){
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}){
      my ($distro_name, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
      foreach my $arch(@{$distro->{arch} }){
        foreach my $section(@{$distro->{sections} }){
          my ($distro, $path,$keyring)=($distro->{name},$repo->{path},$repo->{keyring});
          chdir($path) || die $!;
          system("gzip -c dists/$distro_name/$section/binary-$arch/Packages > dists/$distro/$section/binary-$arch/Packages.gz");
          system("bzip2 -c dists/$distro_name/$section/binary-$arch/Packages > dists/$distro/$section/binary-$arch/Packages.bz2");
          system("chgrp -R ".$config->{group_owner}." $path/dists/$distro_name/$section/binary-$arch"." 2>/dev/null") if $config->{group_owner}  && ($>==0 || $>==uid("$path/dists/$distro_name/$section/binary-$arch"));
          system("chmod -R 775 $path/dists/$distro_name/$section/binary-$arch")  if($>==0 || $>==uid("$path/dists/$distro_name/$section/binary-$arch"));
        }
      }
    }
  }
}






sub read_config {
  my $filename=shift;
  local $/='';
  open CONFIG, "<$filename" || die $!;
  my $config=<CONFIG>;
  close CONFIG;
  return YAML::Load($config);
}



sub get_command_name {
  my @a=(split(/\//,$0));
  return pop @a;
}


#Regenerate the package lists, regenerate
sub rebuild_repository {
  create_dirs();
  foreach my $repo_name(keys %{$config->{repositories}}){
    print "Rebuilding $repo_name\n";
    create_packages_file($config->{repositories}->{$repo_name});
    create_compressed_packages();
    create_release_files($config->{repositories}->{$repo_name},$repo_name);
  }
  create_release_signature;
}

#list all files in the repos.  Right now, this is all files in the repos, not
#necessarily files exported via the packages list.
sub list_repository {
  my $section="";
  if($add_to){
    if($add_to=~m!^(\w*)/(\w*)!){
      $add_to=$1;
      $section=$2;
    }
    foreach my $repo_name(keys %{$config->{repositories}}){
      my $repo=$config->{repositories}->{$repo_name};
      foreach my $distro (@{$repo->{distro}}){
        list_files($repo,$distro,$section) if(($distro->{name} eq $add_to) ||($distro->{simlink} && $distro->{simlink} eq $add_to));
      }
    }
  }else{
    foreach my $repo_name(keys %{$config->{repositories}}){
      my $repo=$config->{repositories}->{$repo_name};
      foreach my $distro (@{$repo->{distro}}){
        foreach my $section(@{$distro->{sections}}){
          list_files($repo,$distro,$section);
        }
      }
    }
  }
}

#Top-level function that copies a package into the correct place in the repos
sub add_package {
  unless(@ARGV>2){
    die "invalid number of arguments to add!\n";
  } 
  my $section="main";
  if($add_to=~m!^(\w*)/(\w*)!){
    $add_to=$1;
    $section=$2;
  }
  #die "Unable to find file $file" unless -e $file;
  foreach my $repo_name(keys %{$config->{repositories}}){
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}){ 
      add_files($repo,$distro,$section,@files) if(($distro->{name} eq $add_to) ||($distro->{simlink} && $distro->{simlink} eq $add_to)) ;
    }
  }
  die "unable to find distro $add_to\n"; 
}

#Below this is for cloning repos

sub sync_packages {
	sync_mirror_lists();
  my %package_hash;
  
  foreach my $repo_name (keys %{$config->{repositories}}) {
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}) {
      foreach my $arch (@{$distro->{arch}}) {

				#build a list of packages available to this distro
        foreach my $section (@{$distro->{sections}}) {
					#clear the list
					%package_hash = ();
          #build url and directory names
          my $package_file = "$distro->{mirror_cache}/$distro->{name}/$section/binary-$arch/Packages.gz";
          print "Reading $package_file ...\n";
          load_package_list($package_file, \%package_hash);


					my @files = ();
					my @packages = @{$distro->{base_packages}};
					if ($distro->{include_essential}) {
						push (@packages, get_essentials(\%package_hash));
					}

					foreach my $package (@packages) {
						push (@files, get_list_of_dependencies($package, \%package_hash));
					}
					
					#uniq names
					@files = keys %{{ map { $_ => 1} @files }};

					#create a temp file to store the list of files that need to be synced
					my ($fh, $filename) = tempfile() or die("Can't create temp file");
					print $fh join("\n",@files);

					my $remote_url = "$distro->{mirror_url}/";
					my $local_dir = "$repo->{path}/pool-$distro->{name}/$section/";
					my $cmd = "$RSYNC $RSYNC_OPTIONS --no-R --files-from=$filename $remote_url $local_dir";
					system("$cmd");

					unlink0($fh, $filename) or print "Error unlinking file $filename safely";	
					$fh->close();
				}
      }
    }
  }
  
	print "Don't forget to rebuild the repository!\n";
  exit;
}

sub get_essentials {
	my $package_hash = shift;
	my @packages;
	while ((my $key, my $value) = each (%{$package_hash})) {
		if ($value->{Essential} && $value->{Essential} =~ /yes/i) {
			push (@packages, $key);
		}
	}
	return @packages;
}

sub get_list_of_dependencies {
  my $package = shift; 
  my $package_hash = shift;
  my $version;

  my %files = (); 
  my @required = ($package);

  while ($package = shift @required) {
    #we'll parse the version, but for now, we'll forget about it
    #since we'll assume the parent repo maintains the appropriate
    #version
    ($package, $version) = split(" ", $package, 2);
    chomp $package;

    if ($files{$package}) {
      next;
    }

    if ($package_hash->{$package}){
      $files{$package} = $package_hash->{$package}->{"Filename"};
      if ($package_hash->{$package}->{"Depends"}) {
        unshift(@required, split(',', $package_hash->{$package}->{"Depends"}));
      }
    } 
    else {
      print "Can't resolve $package\n";
    }

  }

  return values %files;
}


sub sync_mirror_lists {
  foreach my $repo_name (keys %{$config->{repositories}}) {
    my $repo=$config->{repositories}->{$repo_name};
    foreach my $distro (@{$repo->{distro}}) {
      foreach my $section (@{$distro->{sections}}) {
        foreach my $arch (@{$distro->{arch}}) {
          #build url and directory names
          my $remote_url = "$distro->{mirror_url}/dists/$distro->{name}/$section/binary-$arch/Packages.gz";
          my $local_dir = "$distro->{mirror_cache}/$distro->{name}/$section/binary-$arch";
          my $rsync_cmd = "$RSYNC $RSYNC_OPTIONS $remote_url $local_dir";
          unless ( -e "$local_dir"  ) {
            mkpath( "$local_dir" );
          }	 
          #sync the Package list
          system($rsync_cmd);
        }
      }
    }
  }
}

#reads a gzipped package list and parses teh important information
#required for resolving dependencies.
sub load_package_list {
  my $list_name = shift;
  my $package_hash = shift;
  my $gz = gzopen($list_name, "rb") or die("Couldn't read $list_name");

  my $package;

  while ($gz->gzreadline($_) > 0) {
    if (/^Package: (.+)$/) {  ##Package:
      $package = $1;
			
			#this is the beginning of a package section ...
			#for now, with out better reasoning, we will prefer
			#a package "named" for the dependency, rather than
			#"providing" the dependency.  
			if ($package_hash->{$package}) {
				delete $package_hash->{$package};
			}
      $package_hash->{$package}->{"Package"} = $1;
    } 
    elsif (/^Provides: (.+)$/) {
      foreach my $provision (split(", ", $1)) {
        chomp $provision;
        $package_hash->{$provision} = $package_hash->{$package};
      }
    }
    elsif (/^\s*$/) {         ##blank line
      $package = "";
    }
    elsif (/^(\w+): (.+)$/){
      if (grep (/$1/, @pkg_res_fields)) {
        $package_hash->{$package}->{$1} = $2;
      }
    }
  }
  $gz->gzclose();
}
